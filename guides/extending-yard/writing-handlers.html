<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<html> 
  <head> 
    <link rel="icon" type="image/png" href="../../favicon.ico" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="Keywords" content="yard, ruby, software, documentation, uml, tags, metadata, parser, html, yardoc" />
<meta name="Description" content="YARD is an extensible Ruby Documentation Tool (Yay!) for consistent documentation." /> 
<link rel="stylesheet" href="../../css/style.css" type="text/css" charset="utf-8" />
<script type="text/javascript" src="../../js/types.js"></script>
<script type="text/javascript" src="../../js/global.js"></script>

    <title>YARD - Guide: Writing a Handler for Custom Ruby Syntax (DSL)</title> 
    <script type="text/javascript" src="../../js/jquery.js"></script>
    <script type="text/javascript" src="../../js/highlight.pack.js"></script>
    <script type="text/javascript">
      hljs.initHighlightingOnLoad();
      $(generateTOC);
    </script>
  </head> 
  <body> 
    <div class="top wrapper">
  <div id="top">
    <div id="release">
      <p class="version"><strong>Latest Release</strong></p>
      <p class="date"><a href="http://badge.fury.io/rb/yard"><img src="https://badge.fury.io/rb/yard@2x.png" alt="Gem Version" height="18"></a></p>
      <p class="links"><a href="http://rubydoc.info/gems/yard/file/docs/WhatsNew.md">What's New</a> - <a href="http://rubydoc.info/gems/yard/file/README.md">README</a></p>
    </div>
    <a href="../../index.html" id="logo"></a>
    <!--
    <img src="http://waiau.wikispaces.com/file/view/pirate.gif/84085425/pirate.gif" height="60" style="position:relative;top:0px;left:260px;">
    <div style="position:absolute;top:60px;margin-left:5px; background: #fff; padding: 4px;"><strong>Yarr!</strong> A Ruby documentation tool!</div>
    -->
    <ul id="nav">
      <li><a href="../../index.html">Home</a></li>
      <li><a href="../../features.html">Features</a></li>
      <li><a href="../../guides/index.html">Guides</a></li>
      <li><a href="http://github.com/lsegal/yard">Source</a></li>
      <li><a href="http://rubydoc.info">RubyDoc.info</a></li>
    </ul>
  </div>
</div>

    <div class="light wrapper">
      <div id="content" class="guide">
        <div class="breadcrumb"><a href="../../guides/index.html">Guides</a> &raquo;</div>
        <h1>Writing a Handler for Custom Ruby Syntax (DSL)</h1>




<p>This guide will explain how to use YARD to document a Domain Specific Language
(DSL) or custom Ruby syntax.</p>




<h2>A Hello World Handler</h2>




<p>The most basic handler is implemented by inheriting from the
<a href="http://rubydoc.info/gems/yard/YARD/Handlers/Ruby/Base">YARD::Handlers::Ruby::Base</a>
class. By subclassing, our handler is immediately registered and is checked
whenever a statement is parsed. The following is the most basic handler.</p>




<pre><code class="ruby">class MyHandler &lt; YARD::Handlers::Ruby::Base
  handles :class

  process do
    puts "Handling a class statement!"
  end
end
</code></pre>




<p>This handler will tell us whenever a class is processed.</p>




<p><span class="note"><em>Note: the <code>process do ... end</code> block is equivalent to defining <code>#process</code> method.</em></span></p>




<h3>How Handlers Get Called</h3>




<p>To understand how and when this handler is called, we must briefly explain how
YARD processes source files. When a Ruby source file is parsed, it is done
statement by statement. For each statement, YARD checks the list of registered
handlers for all of the handlers that are set to "handle" the statement.
Whichever handlers match will be called (by executing the <code>#process</code> method).</p>




<h3>Nodes and the AST</h3>




<p>Statements are passed into the <code>#process</code> method as an
<a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a> (AST).
Each node in the AST has a <code>#type</code> which uniquely identifies the node type. YARD
uses Ripper to parse the AST, and therefore a full list of node types can be
found by running <code>ruby -rripper -e 'puts Ripper::EVENTS'</code> or in irb:</p>




<pre><code>&gt;&gt; require 'ripper'
=&gt; true
&gt;&gt; Ripper::EVENTS
=&gt; [:BEGIN, :END, :alias, :alias_error, :aref, :aref_field,
 :arg_ambiguous, :arg_paren, :args_add, :args_add_block, :args_add_star,
 :args_new, :array, :assign, :assign_error, :assoc_new,
 :assoclist_from_args, :bare_assoc_hash, :begin, :binary, :block_var,
 :block_var_add_block, :block_var_add_star, :blockarg, :bodystmt,
 :brace_block, :break, :call, :case, :class, :class_name_error, :command,
 :command_call, :const_path_field, :const_path_ref, :const_ref, :def,
 :defined, :defs, :do_block, :dot2, :dot3, :dyna_symbol, :else, :elsif,
 :ensure, :excessed_comma, :fcall, :field, :for, :hash, :if, :if_mod,
 :ifop, :lambda, :magic_comment, :massign, :method_add_arg,
 :method_add_block, :mlhs_add, :mlhs_add_star, :mlhs_new, :mlhs_paren,
 :module, :mrhs_add, :mrhs_add_star, :mrhs_new, :mrhs_new_from_args,
 :next, :opassign, :operator_ambiguous, :param_error, :params, :paren,
 :parse_error, :program, :qwords_add, :qwords_new, :redo, :regexp_add,
 :regexp_literal, :regexp_new, :rescue, :rescue_mod, :rest_param, :retry,
 :return, :return0, :sclass, :stmts_add, :stmts_new, :string_add,
 :string_concat, :string_content, :string_dvar, :string_embexpr,
 :string_literal, :super, :symbol, :symbol_literal, :top_const_field,
 :top_const_ref, :unary, :undef, :unless, :unless_mod, :until, :until_mod,
 :var_alias, :var_field, :var_ref, :void_stmt, :when, :while, :while_mod,
 :word_add, :word_new, :words_add, :words_new, :xstring_add,
 :xstring_literal, :xstring_new, :yield, :yield0, :zsuper, :CHAR,
 :__end__, :backref, :backtick, :comma, :comment, :const, :cvar, :embdoc,
 :embdoc_beg, :embdoc_end, :embexpr_beg, :embexpr_end, :embvar, :float,
 :gvar, :heredoc_beg, :heredoc_end, :ident, :ignored_nl, :int, :ivar, :kw,
 :label, :lbrace, :lbracket, :lparen, :nl, :op, :period, :qwords_beg,
 :rbrace, :rbracket, :regexp_beg, :regexp_end, :rparen, :semicolon, :sp,
 :symbeg, :tlambda, :tlambeg, :tstring_beg, :tstring_content,
 :tstring_end, :words_beg, :words_sep]
</code></pre>




<p><span class="note warn">You should consult <a href="http://www.rubydoc.info/stdlib/ripper">Ripper documentation</a>
on the meaning of each node type, though currently the documentation for these
nodes is sparse.</span></p>




<p>You do not need to know each node, just that there are many kinds of nodes to
express the various Ruby statements. We will use these nodes to tell our
handler what statement to match.</p>




<h3>Matchers</h3>




<p>The <a href="http://rubydoc.info/gems/yard/YARD/Handlers/Base#handles-class_method"><code>handles</code></a>
statement above therefore describes to YARD which statements a handler should
process. We call these "<strong>matchers</strong>", because they determine if the current
statement matches the handler.</p>




<p>The most basic matcher is a Symbol value that represents the node type of the
statement. In our example above, we are looking for any statement which is
represented by the <code>:class</code> node, also known as the "class" statement. A full
list of nodes can be found in the Ripper documentation.</p>




<p>A handler can have multiple handles statements and multiple matchers in each
statement. The following is also valid:</p>




<pre><code class="ruby">class MyHandler &lt; YARD::Handlers::Ruby::Base
  handles :class, :sclass
  handles :module

  process do end
end
</code></pre>




<p>The above handler would handle classes and modules.</p>




<p><span class="note"><em>Note: <code>:sclass</code> is the node for <code>class &lt;&lt; obj</code> blocks.</em> </span></p>




<h3>Meta and Special Matchers</h3>




<p>We discussed basic matchers based on a node type, but you can also create more
complex custom matchers by subclassing the
<a href="http://rubydoc.info/gems/yard/YARD/Handlers/Ruby/HandlesExtension">HandlesExtension</a>
class which responds to <code>#matches?</code>. YARD has a few of these matchers already
available for common tasks, like matching method calls and conditionals.</p>




<p>Specifically, the new-style handlers provide the two matcher extensions
<a href="http://rubydoc.info/gems/yard/YARD/Handlers/Ruby/Base#method_call-class_method"><code>method_call</code></a>
and <a href="http://rubydoc.info/gems/yard/YARD/Handlers/Ruby/Base#meta_type-class_method"><code>meta_type</code></a>. Which can
be used in the form:</p>




<pre><code class="ruby">handles method_call(:describe)
</code></pre>




<p>Which will match the method call <code>describe</code> in the forms:</p>




<pre><code class="ruby">object.describe do ... end
describe(foo)
describe 'a', 'b', 'c'
...
</code></pre>




<p>You can also match all conditionals (if, unless, etc.) in one shot with:</p>




<pre><code class="ruby">handles meta_type(:condition)
</code></pre>




<p>Which calls <code>#condition?</code> on the node. A full set of meta-types that can be
tested for is found in the <a href="http://rubydoc.info/gems/yard/YARD/Parser/Ruby/AstNode">AstNode</a>
class.</p>




<h2>Creating a Simple DSL Handler</h2>




<p>Now that we have the basics out of the way, we can create our first handler for
a DSL syntax. Let's say, for our example, that our framework has a method
<code>cattr_accessor</code> that we want to document in our HTML documentation as class
level read/write attributes. To show an example, we want to document this:</p>




<pre><code class="ruby">class OurClass
  cattr_accessor :foo
end
</code></pre>




<p>As if it were written like this:</p>




<pre><code class="ruby">class OurClass
  class &lt;&lt; self
    attr_accessor :foo
  end
end
</code></pre>




<p>With YARD, it's quite simple. Here is our handler:</p>




<pre><code class="ruby">class ClassAttributeHandler &lt; YARD::Handlers::Ruby::AttributeHandler
  handles method_call(:cattr_accessor)
  namespace_only

  process do
    push_state(:scope =&gt; :class) { super }
  end
end
</code></pre>




<p>First we should note that we've subclassed the
<a href="http://rubydoc.info/gems/yard/YARD/Handlers/Ruby/AttributeHandler">AttributeHandler</a>
class to do most of the legwork in creating our actual attribute objects for
us, since our DSL is basically an attribute but in the "class" scope. We
then setup a matcher for the <code>cattr_accessor</code> method call (described above).</p>




<p>You'll now notice something we never discussed before, the
<a href="http://rubydoc.info/gems/yard/YARD/Handlers/Base#namespace_only-class_method"><code>namespace_only</code></a>
method. This declaration tells our handler that we should only match method
calls inside a namespace (class or module), not inside a method. This is not
strictly necessary, but it avoids dealing with dynamic attributes and method
calls that may not really be attribute declarations at all.</p>




<p>Our process method simply calls
<a href="http://rubydoc.info/gems/yard/YARD/Handlers/Base#push_state-instance_method"><code>#push_state</code></a>
to set our scope to "class" level before calling super and running the
<code>AttributeHandler</code>'s process method. This basically makes our <code>AttributeHandler</code>
class run inside the class level and create attributes on our class rather than
as instance methods.</p>




<h2>Creating and Modifying Objects in a Handler and Processing Blocks</h2>




<p>We just saw a very simple handler that didn't do very much manipulation or
object creation. Often, however, the purpose of a handler is to create a new
<a href="http://rubydoc.info/gems/yard/YARD/CodeObjects/Base"><code>CodeObject</code></a> or modify
an existing one. To illustrate how to create and manipulate these code objects
in YARD, let's look at a very simple DSL that creates new method objects that
we'd want to document. Our DSL would create instance methods using the function
"methodify":</p>




<pre><code class="ruby">class SomeClass
  methodify "foo" do
    raise NotImplementedError
  end
end
</code></pre>




<p>In the above example, we'd want to document "foo" as an instance method inside
of "SomeClass". This time we will not subclass an existing handler, but rather
we will create the method object ourselves. Let's look at the handler code
to achieve this.</p>




<pre><code class="ruby">class MethodifyHandler &lt; YARD::Handlers::Ruby::Base
  handles method_call(:methodify)
  namespace_only

  process do
    name = statement.parameters.first.jump(:tstring_content, :ident).source
    object = YARD::CodeObjects::MethodObject.new(namespace, name)
    register(object)
    parse_block(statement.last.last, :owner =&gt; object)

    # modify the object
    object.dynamic = true

    # add custom metadata to the object
    object['custom_field'] = 'Generated by Methodify'
  end
end
</code></pre>




<p>From the previous example you should already be familiar with the first few
lines of this handler. We are matching a method call for "methodify" inside a
namespace.</p>




<p>The process method is where it all gets interesting. On the first line of the
method you will see that we access the <code>statement</code> object, which pertains to
the root node of our current statement. Because our statement is a method call,
we are dealing with a <a href="http://rubydoc.info/gems/yard/YARD/Parser/Ruby/MethodCallNode"><code>MethodCallNode</code></a>
which has a list of parameters. We then take the first parameter and "jump"
inside the string's quotes and get the inner text, which will become our method
name. The next line creates our <code>MethodObject</code> by name in our current "namespace"
(the current lexical module/class).</p>




<p>Now we need to <a href="http://rubydoc.info/gems/yard/YARD/Handlers/Base#register-instance_method"><code>#register</code></a>
the object. This method is not strictly necessary, but is a helper method
in handlers used to add common attributes to an object, like line range for
the source code, file name the object is located in, source language, and other
attributes.</p>




<p>We then parse the block (the inside of the method). YARD by default does not
parse statements inside a block unless told to do so with this method. Again,
it not strictly necessary, but it allows YARD to run handlers for statements
inside of our method (like generating a tag for that "raise" method). The
<a href="http://rubydoc.info/gems/yard/YARD/Handlers/Ruby/Base#parse_block-instance_method"><code>#parse_block</code></a>
method does this for us, and takes two parameters: the node with the block and
any extra state information to push while inside the block (similar to the
<code>push_state</code> method we saw before). <code>statement.last.last</code> is the list of
statements inside our block. For our state, we use <code>:owner</code> to specify that
we are inside of the "foo" method. We use <code>:owner</code> instead of <code>:namespace</code>
because a method is not a namespace. To clarify, <code>:owner</code> is a special state
object to keep track of a lexical position inside non-namespace objects like
methods. The distinction between an owner and a namespace is important because
of Ruby's name resolution rules (it must always know what "namespace" it is
inside of).</p>




<p>After we parsed the method contents, we set some more data on our new object.
Neither of these are necessary, they are just here to illustrate that we can
modify our object after it's been created. First we make it "dynamic", because
it was generated dynamically (just as a note to the user). We then create a
custom field on our object that will store a little notice that the method was
created with our DSL. We could utilize this information later in a custom theme,
if we wanted.</p>




<h2>Running Our Handlers in YARD</h2>




<p>We talked about how to implement handlers, but you may still be wondering where
this Ruby code goes and how we call on it. There are a few ways to answer this
question, but in both cases we would create a separate source .rb file with our
handler and other extension code, and load it in our runtime. A good place to put
extensions is in a <code>yard_extensions.rb</code> file in the root of the project, or
create a separate directory for these files.</p>




<p>If you're running inside of a Rake task, we need only to <code>require</code> our Ruby
source file and have the handlers loaded into the runtime. The top of your
<code>Rakefile</code> would look like:</p>




<pre><code class="ruby">require 'yard'
require_relative './yard_extensions'
</code></pre>




<p>If you're running the <code>yardoc</code> tool from the command line, there is a
<code>-e</code> (<code>--load</code>) command-line switch to load a Ruby file before parsing source.
In this case, you would use the command:</p>




<pre><code class="sh">$ yardoc -e yard_extensions.rb 'lib/**/*.rb'
</code></pre>




<p>You can also create a plugin that is installed in your gem library and
automatically loaded by YARD.</p>


      </div> 
    </div>
    <div class="copyright wrapper">
  <div id="copyright">
    <p>Copyright &copy; 2007-2020. YARD is written by
    <a href="http://gnuu.org">Loren Segal</a>. 
    Design by <a href="http://gnuu.org">gnuu.org</a>. 
    YARD uses the MIT License.</p>
  </div>
</div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-7172246-6', 'yardoc.org');
  ga('send', 'pageview');

</script>

  </body> 
</html>
